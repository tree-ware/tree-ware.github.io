{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Accelerate your software development!</p>"},{"location":"docs/","title":"Docs","text":"<ul> <li>Kotlin Core</li> <li>Kotlin MySQL</li> <li>Kotlin Server</li> <li>Angular UI</li> </ul>"},{"location":"presentations/","title":"Presentations","text":""},{"location":"presentations/#videos","title":"Videos","text":"<ul> <li>Tree Ware Intro &amp; Demo</li> </ul>"},{"location":"presentations/#slides","title":"Slides","text":"<ul> <li>Tree-Ware Introduction</li> <li>Tree-Ware Architecture</li> </ul>"},{"location":"presentations/tree-ware-architecture/","title":"Tree ware architecture","text":"Tree-Ware Architecture <p>Accelerate your software development!</p> Data-First The data corresponding to features must be defined first Model The runtime data is called Model It is (primarily) a tree structure Meta-Model The definition for the Model is called Meta-Model Many data types are supported Packages, Entities, Fields, Enumerations, Primitives, Aliases Compositions (nested entities) make it a tree Associations (references to other entities) make it a directed-graph Various constraints can be declared in the meta-model Aux Data Auxiliary data can be attached to any node in the model tree Used for cross-cutting aspects Examples: errors, access-control definitions, DB mappings Model Operator Operates on one or more models Codec: encode/decode JSON, Protobuf, SQL, etc Intersection: determine what is common between 2 or more models Union: determine the combination of 2 or more models Difference: determine the difference between 2 models Operators can be composed to create versatile expressions System Architecture There is a pipeline from the UI to the DB and beyond Models flow through this pipeline in both directions Most pipeline stages implement cross-cutting aspects Custom business-logic is also a stage in the pipeline Each cross-cutting stage is implemented as an operator The pipeline is in essence an expression composed of operators Architecture Benefits The pipeline can be run on a single machine or distributed across multiple machines <p>The pipeline can support new features</p> <p>without glue logic for cross-cutting aspects</p> <p>New cross-cutting aspects can be inserted</p> <p>as pipeline stages</p> <p>without modifying existing features</p> Tree-Ware Design Pattern Use models for feature-data Use aux data for cross-cutting aspects Use model operators to implement cross-cutting aspects API Get-requests are model trees specifying the parts of the model to be returned Get-responses are model trees corresponding to the parts requested Set-requests are model trees containing the nodes to be created/updated/deleted Set-request models are validated against the meta-model Fan-out: a request can be split into smaller trees and load-balanced to different servers Fan-in: responses from the fan-out can be combined into a single response Stream: responses from the fan-out can be streamed back to the client as they arrive Both set-requests and get-requests are via HTTPS POST and JSON RBAC <p>An RBAC role is a model that only contains nodes that are accessible</p> <p>Aux data on these nodes specify the required permissions</p> An intersection operator intersects API requests/responses with the RBAC model Only the common parts (the intersection result) are permitted to the next stage in the pipeline Feature-Flags Extremely fine-grained feature-flags at the individual field level Aux data indicates readiness: in-progress, developed, tested, released, etc. A filter operator can filter a model based on readiness DB The model is mapped automatically to appropriate databases <p>Configuration is mapped to an SQL database</p> <p>State/metrics is mapped to a metrics database</p> Schema for the databases is taken care of by tree-ware Code for writing to and reading from the databases is taken care of by tree-ware API &amp; DB Migration Meta-model evolution is validated to ensure changes are backward-compatible The difference operator is used on the new version and the previously released version API and DB migrations are generated based on the differences computed by the operator Code Generation Most of tree-ware is data-driven, but a few things are generated OpenAPI (Swagger) specification UML diagram of the model Typesafe model classes for use in business-logic Liquibase DB schemas and DB migration scripts Supported Languages <p>Kotlin</p> <p>Java</p> <p>TypeScript</p> <p>JavaScript</p> <p>Native (Android/iOS)</p> Foundations <p>Functional Programming</p> <p>Abstract Algebra</p> Mini Design Exercise Recap: Tree-Ware Design Pattern Use models for feature-data Use aux data for cross-cutting aspects Use model operators to implement cross-cutting aspects Given a model tree of ONLY the config How do we generate a UI for it? Hint 1: a UI is a tree Hint 2: JSON is a tree How do we customize the components shown for certain fields? Given a model tree of config AND state <p>How do we get a model tree of:</p> <p>only the config?</p> <p>How do we get a model tree of:</p> <p>only the released config?</p> <p>How do we get a model tree of:</p> <p>only the released config the user has access to?</p> How many times do we have to walk the input model tree? The End"},{"location":"presentations/tree-ware-introduction/","title":"Tree ware introduction","text":"Tree-Ware Introduction <p>Accelerate your software development!</p> The Problem Companies struggle with feature velocity They use a lot of open-source software to speed up their development But that alone is NOT sufficient! Every feature requires a lot of cross-cutting aspects to be implemented UI for user-input and feature-metrics APIs for user input and feature metrics RBAC for the APIs Caching Storage for user input and feature metrics Full-text search Rolling up of feature metrics across space &amp; time And a lot more such cross-cutting aspects There is open-source software for each of the above, but they need to be glued together for each feature New features require glue-logic for cross-cutting aspects New cross-cutting aspects require updates in existing features <p>The initial rush-to-market results in</p> <p>many of the cross-cutting aspects being left out</p> <p>and inconsistently implemented features</p> Inconsistent feature implementations make it hard to add new cross-cutting aspects The Solution tree-ware         An end-to-end declarative open-source framework      <p>End-to-end</p> <p>UIs, APIs, load-balancers, caches, databases, compute-pipelines, devices</p> <p>Declarative</p> <p>System-wide schema specified by developers</p> <p>Open-source</p> <p>https://github.com/tree-ware</p> <p>Tree-ware lets you rush-to-market</p> <p>with a slew of cross-cutting aspects included out of the box</p> <p>and consistently implemented features</p> New features automatically get cross-cutting aspects from tree-ware New cross-cutting aspects do NOT require updates in existing features Work Involved? <p>Developers only define the following:</p> <ol> <li>a schema for the product/service data</li> <li>custom business-logic</li> </ol> Tree-ware takes care of everything else How Does it Work? Tree-ware uses a data-first approach Developers define the data corresponding to the features And tree-ware provides the cross-cutting aspects <p>It sets up &amp; operates infrastructure</p> <p>for</p> <p>the data defined in the schema</p> It provides the glue-logic for the necessary infrastructure <p>It uses existing infrastructure:</p> <p>Databases, queues, compute-pipelines, etc.</p> <p>And provides other custom infrastructure:</p> <p>UI, load-balancer, API server, cache, RBAC, feature-flags, etc.</p> Common Concerns Tree-ware has solved common concerns people have with such frameworks What if I want to do something the framework does not support? <p>Tree-ware does not limit what can be done</p> <p>It is modular and custom code can be inserted wherever needed</p> How do I prevent the framework from overwriting my manually written code? Tree-ware generated code and manually written code do not exist in the same files Can it scale? Tree-ware was built from the ground up for scale What's the Catch? <p>It is less than ideal for existing systems</p> <p>But it is perfect for brand new systems</p> <p>It is not fully implemented</p> <p>But there is enough for a first release</p> <p>And it is a great foundation to build on</p> Recap Tree-ware accelerates feature development by taking care of all cross-cutting aspects <p>Developers only define the following:</p> <ol> <li>a schema for the product/service data</li> <li>custom business-logic</li> </ol> New cross-cutting aspects can be added WITHOUT modifying existing features The End"}]}